# http 协议

## [浏览器工作过程](https://juejin.im/post/5d5e795ff265da03e275f29e)

> URL 解析

- 地址解析：判断是输入的 url 还是搜索关键字
- hsts: 是否强制客户端使用 https 访问页面
- 检查缓存。如果有缓存，那么就从缓存中取数据

> DNS 寻址查询

- 浏览器缓存
- 操作系统缓存
- 路由器缓存
- ISP DNS 缓存
- 根域名服务器查询

> TCP 连接

- 应用层：发送 http 请求
- 传输层：TCP 传输报文
- 网络层：IP 协议查询 mac 地址
- 链路层：以太网协议
  - 以太网协议，将数据分为以帧为单位的数据包
  - mac 地址，也就是网卡地址。 连入网络的所有设备都必须具备’网卡‘接口，每一个网卡地址都是独一无二的。
  - 广播，向本网络的所有机器发送，
  - 服务器接收请求。也就是拆包的过程。

> 处理请求

- HTTPD: 最常见的就是 Apache 和 Nginx，以及 Windows 上的 IIS。 Nginx 会监听得到的请求，然后开启一个子进程，去处理这个请求。
- 处理请求：对 HTTP 协议进行解析（请求方法、域名、路径等）
- 重定向：如果服务器配置了 HTTP 重定向，就会返回一个 301 重定向。浏览器就会根据响应，重新发送 http 请求
- url 重写：会查看 url 重写规则，如果文件真实存在（比如图片、html、css、js 等文件），则会直接返回。不然的话就会把请求重写到一个 REST 风格的 URL 上，然后服务器处理并返回请求
  > 接收响应
- 查看 Response header,根据不同状态码做不同的事情(比如 301 重定向)
- 如果响应资源进行了压缩（比如 gzip），还需要进行解压
- 对响应的资源进行缓存
- 根据响应资源里面的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方法）

> 渲染页面

- HTML 解析： 解码、预解析、符号化、构建 DOM 树
- CSS 解析：CSS 解析器会处理它遇到的任何 CSS,并得到标记化后的规则表。
- 渲染树：其实就是 DOM 树和 CSS 规则树合并的过程。
  - 计算：让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把 rem 转化为 px。
  - 级联：specificity 的公式会通过 1、标签名、class、id 2、是否内联样式 3、!important 然后得出一个权重值，取最高的那个。
  - 渲染阻塞：CSSh 会阻塞 JS 执行，JS 会阻塞后面的 DOM 解析。所以就有了下面的原则：他们之间的顺序就是 HTML、CSS、JS
- 布局和绘制：确定所有节点的几何属性（位置、大小），然后输入到一个盒子模型中。 然后遍历渲染树、调用渲染器额 paint()方法在屏幕上显示其内容
- 合并渲染层：将是所有图片合并，最终输出成一张图片
- 回流与重绘：某个部分的变化影响了布局时，就会引发回流；而只是元素的背景色改变、或者文字颜色改变等等，不会影响周围元素的位置变化时，就是发生重绘
  - 回流的成本要比重绘的成本高。所以尽量避免回流。比如：display:none 会触发回流；而 visibility:hidden 只会触发重绘

> js 编译执行

- 词法分析
- 预编译 创建执行上下文
- 执行
  - 虽然 JS 是单线程的、但是实际参与工作的线程一共有 4 个。JS 引擎线程才是真正执行的，事件触发线程、定时器触发线程、HTTP 异步请求线程都是协助的。
  - 宏任务和微任务
    - 其中，宏任务分为同步宏任务和异步宏任务（异步宏任务包括异步 Ajax--Asynchronous JavaScript and XML）。微任务是 ES6h 或者 Node 环境下，主要的 API 有：Promise、process.nextTick
- ![宏任务和微任务]()
